# 一、课程概述

Linux系统的理解及学习Linux内核的心得

# 二、课程进行知识点总结

## 第一节、计算机是如何工作的

### 1.存储程序计算机工作模型

![这里写图片描述](http://img.blog.csdn.net/20170423112617986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NzA4Njk4NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 2.x86CPU的寄存器
通用寄存器、段寄存器、标志寄存器等。

### 3.计算机的汇编指令

#### （1）movl指令：

| 寻址方式 | 描述 |
| --- | ---- |
| **寄存器寻址** |寄存器模式，以％开头的寄存器标示符。不和内存打交道，eax赋值给edx |
|**立即寻址** |把立即数直接放在寄存器，立即数是以$开头的数值|
| **直接寻址**|直接访问一个指定的内存地址的数据；
| **间接寻址**|将寄存器的值作为一个内存地址来访问内存；
| **变址寻址**|在间接寻址之时改变寄存器的数值。
 　
**注意**：AT&T汇编格式与Intel汇编格式略有不同，Linux内核使用的是AT&T汇编格式。

#### （2）其他指令

堆栈是向下增长的，有一个基址ebp指向堆栈栈底

| 指令 | 描述 |
| --- | ---- |
| pushl | 压栈，esp减4，把eax放入esp内存位置 |
| popl | 出栈，从堆栈栈顶取32位放到寄存器eax里面，有两个动作：首先间接寻址，把栈顶数值放到eax里面，再把栈顶加4 |
| call | 函数调用，把当前的eip压栈，给eip赋新值 |
　 
**注意**：*是指这些指令是伪指令，程序员不能直接修改这些，即eip寄存器不能被直接修改，只能通过特殊指令间接修改。

### 4.将C代码编译成汇编代码

#### （1）函数调用堆栈是由逻辑上多个堆栈叠加起来的

#### （2）函数的返回值默认使用eax寄存器存储返回给上一级函数

#### （3）使用命令编译成汇编代码：gcc –S –o main.s main.c -m32

### 5.部分测验
1. 假定当前是32位X86机器，函数的返回值默认使用哪个寄存器来返回给上级函数？
**答**：eax 或 EAX 或 %eax

2. 下面哪条指令的寻址方式是直接寻址方式？
	A. movl %eax, %edx
	B. movw $0x123, %ax
	C. movb 0x12, %ah
	D. movl (%ebx), %edx
**答**：C

## 第二节、操作系统是如何工作的

### 1. 堆栈
堆栈式C语言程序运行时必须的一个记录调用路径和参数的空间。包括：函数调用框架；传递参数；保存返回地址（如eax）；提供局部变量空间

### 2. 堆栈寄存器
esp 堆栈指针和ebp 基址指针（在C语言中表示当前函数调用基址）

### 3. 堆栈操作
push栈顶指针减少4个字节（32位）和pop 栈顶指针增加4个字节

### 4. 参数传递与局部变量

#### （1）建立框架（相当于 call 指令）

```
push %ebp
movl %esp,%ebp
```

#### （2）拆除框架（相当于 ret 指令）

```
movl %ebp,%esp

pop  %ebp
```

函数返回时一定会拆除框架，建立和拆除是一一对应的。

#### （3）传递参数

在建立子函数的框架之前，局部变量的值保存在调用者堆栈框架中，所以在子函数框架建立之前可以采用变址寻址的方式将变量值入栈。

函数的返回值通过eax寄存器传递

## 第三节、构造一个简单的Linux系统MenuOS

### 1. 计算机三个法宝
存储程序计算机、函数调用堆栈、中断

### 2. 操作系统两把宝剑
中断上下文的切换（保存现场和恢复现场）以及进程上下文的切换

### 3. 小结

系统进入start\_kernel这个函数之前已经进行了一些最低限度的初始化，再往前研究就涉及很多硬件相关及编程语言了。内核即进入了C语言部分，它完成了内核的大部分初始化工作。实际上，可以将start_kernel函数看做内核的main函数。

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。整个linux系统的所有进程也是一个树形结构。Linux下有3个特殊的进程，idle进程(PID = 0), init进程(PID = 1)和kthreadd(PID = 2)。

最初执行的进程即是0号进程init\_task，它是被静态产生的，内存栈的位置固定,执行一些初始化的工作。一直到start\_kernel开始调用执行sched\_init()，0号进程被init_idle(current, smp_processor_id())进程初始化成为一个idle task,变成上一次实验中的进程一样的，通过一个while循环不断执行，只要运行栈里没有别的进程它就执行，循环中不断检测运行栈里是否有其他进程并通过schedule函数进行调度。

init进程由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序,是系统中所有其它用户进程的祖先进程Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。

kthreadd进程由idle通过kernel\_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理，它的任务就是管理和调度其他内核线程kernel_thread, 会循环执行一个kthread的函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程。

## 第四节、扒开系统调用的三层皮（上）

### 1.用户态和内核态

用户态：在相应的低执行状态下，代码的掌控范围受到限制，只能在对应级别允许的范围内活动
内核态：在高执行级别下，代码可以执行特权指令，访问任意的物理地址。
Intel x86 CPU有四种不同的执行级别0—3，Linux只是用了期中的0级和3级分别表示内核态和用户态。

### 2.理解中断处理的完整过程
中断信号（int指令）完成：保存cs:eip的值、当前堆栈段栈顶和当前标志，同时加载了当前中断信号或是系统调用的相关联的中断服务入口到cs:eip里面，把当前对战段和esp也加载到CPU里面。

SAVE ALL完成后若没有发生调度，则接着执行RESTORE_ALL；若发生进程调度，则当前的状态会暂时的保存在系统里面，当下一次发生进程调度切换到当前进程时再接着执行完毕。

### 3. 系统调用的三个层次

系统调用的三个层次依次是：xyz函数（API）、system_ call（中断向量）和 sys_ xyz（中断服务程序）。

### 4. 小结：

系统调用是用户态与内核态的桥梁，而具体的措施就是中断。通过本实验，更加熟悉了系统调用的本质，以及系统调用和中断的关联。应用程序在用户态调用API函数，该函数将对应的系统调用号及参数保存，触发软中断，然后陷入内核态，system_call根据系统调用号调用对应的内核函数，内核函数执行完毕后将结果存放的eax中并返回给程序，程序返回的用户态。

## 第五节、扒开系统调用的三层皮（下）

### 1. make rootfs
一个脚本，自动编译自动生成根文件系统，并自动启动MenuOS。

### 2. gdb

```
（gdb）file linux-3.18.6/vmlinux  //在gdb界面中targe remote之前加载符号表

（gdb）target remote:1234  //建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行

（gdb）b sys_time

（gdb）c   //启动到MenuOs，在MenuOs中使用time，会停在time函数处

（gdb）list  //对应代码

（gdb）s    //单步执行

（gdb）finish  //将这个函数执行完
```

### 3. 32位x86 Linux系统中系统调用处理过程的最后一条汇编指令是iret。

### 4. Linux内核中，系统调用处理过程中保护现场使用的宏是SAVE_ALL。

### 5. 总结
- 执行int 0x80指令后系统从用户态进入内核态，跳到system_call()函数处执行相应服务进程。在此过程中内核先保存中断环境，然后执行系统调用函数。
- system_call()函数通过系统调用号查找系统调用表sys_cal_table来查找具体系统调用服务进程。
- 执行完系统调用后，iret之前，内核会检查是否有新的中断产生、是否需要进程切换、是否学要处理其它进程发送过来的信号等。
- 内核是处理各种系统调用的中断集合，通过中断机制实现进程上下文的切换，通过系统调用管理整个计算机软硬件资源。 
- 如没有新的中断，restore保存的中断环境并返回用户态完成一个系统调用过程。




## 第六节、分析Linux内核创建一个新进程的过程

操作系统内核三大功能：进程管理（核心）、内存管理和文件系统。

### 1.Linux通过复制父进程来创建一个新进程,通过调用do_fork来实现。

### 2.Linux为每个新创建的进程动态地分配一个task_struct结构。

### 3.进程管理

为了把内核中的所有进程组织起来，Linux提供了几种组织方式，其中哈希表和双向循环链表方式是针对系统中的所有进程（包括内核线程），而运行队列和等待队列是把处于同一状态的进程组织起来。

### 4.fork()函数被调用一次，但返回两次。

### 5.小结

创建一个新进程在内核中的执行过程大致如下: 
1. 使用系统调用Sys_clone(或fork,vfork)系统调用创建一个新进程，而且都是通过调用do_fork来实现进程的创建； 
2. Linux通过复制父进程PCB的task_struct来创建一个新进程，要给新进程分配一个新的内核堆栈; 
3. 要修改复制过来的进程数据，比如pid、进程链表等等执行copy_process和copy_thread 
4. p->thread.sp = (unsigned long) childregs; //调度到子进程时的内核栈顶 
5. p->thread.ip = (unsigned long) ret_from_fork; //调度到子进程时的第一条指令地址

## 第七节、 Linux内核如何装载和启动一个可执行程序

### 1．可执行程序过程
先预处理.cpp，在编译成汇编代码.s到目标代码.o，再链接成可执行文件，加载到内存中执行。

### 2．可执行文件加载到内存中开始执行的第一行代码,0X8048X00为实际的入口。

### 3. 动态链接分为可执行程序装载时动态链接和运行时动态链接。

### 4. do_ execve
do_ execve调用do_ execve_ common，do_ execve_ common主要依靠exec_ binprm，其中重要的函数：search_binary_handler(bprm)。

### 5.小结
新的可执行程序是从new\_ip开始执行,start_thread实际上是把返回到用户态的位置从Int 0x80的下一条指令，变成了规定的新加载的可执行文件的入口位置,即修改内核堆栈的EIP的值作为新程序的起点。 

当执行到execve系统调用时，陷入内核态，用execve加载的可执行文件覆盖当前进程的可执行程序，当execve系统调用返回时，返回新的可执行程序的执行起点（main函数位置），所以execve系统调用返回后新的可执行程序能顺利执行。 

对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时，如果是静态链接，elf_entry指向可执行文件规定的头部（main函数对应的位置0x8048***）；如果需要依赖动态链接库，elf_entry指向动态链接器的起点。动态链接主要是由动态链接器ld来完成的。

## 第八节、进程的切换和系统的一般执行过程

### 1. 进程调度算法——每个进程对CPU、I/O等资源需求不一样。

第一种分类：I/O密集型（I/O-bound）和CPU密集型（CPU-bound）
第二种分类：批处理进程；实时进程；交互式进程

### 2. 进程调度（schedule()函数实现）的时机：

中断处理过程（包括时钟中断、I/O中断、系统调用和异常）中，直接调用schedule()，或者返回用户态时根据need_resched标记调用schedule()；
内核线程（只有内核态没有用户态）可以直接调用schedule()进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；
用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度，即在中断处理过程中进行调度。
注意：用户态进程只能被动调度，内核线程是只有内核态没有用户态的特殊进程。

### 3. 操作系统（任何计算机系统都包含一个基本的程序集合）有两个目的：

与硬件交互，管理所有的硬件资源；
为用户程序（应用程序）提供一个良好的执行环境。

### 4. 小结
本次课程学习了操作系统如何进行进程的切换以及系统的一般执行过程。其中还是脱离不出中断的使用，进程切换最主要的时机就在于中断的过程，对关键函数switch\_to的跟踪分析以及函数解读清晰地展示了堆栈如何变化的。

schedule()函数用来选择一个新的进程来运行，并调用context_switch()进行上下文的切换，这个宏调用switch_to()来进行关键上下文切换，其中pick_next_task()函数封装了进程调度算法。



# 博客作业

[第1节 反汇编一个简单的C程序【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/56282546)

[第2节 一个简单的时间片轮转多道程序内核代码【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/60148177)

[第3节 跟踪分析Linux内核的启动过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/61656277)

[第4节 使用库函数API和C代码中嵌入汇编代码两种方式使用同一个系统调用【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/63686845)

[第5节 分析system_call中断处理过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/66479846)

[第6节 分析Linux内核创建一个新进程的过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/68953502)

[第7节 Linux内核如何装载和启动一个可执行程序【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/69939026)

[第8节 理解进程调度时机跟踪分析进程调度与进程切换的过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/70198782)

# 学习心得体会

通过半个学期的学习，我认为重要的不是学习到了多少内核代码（其实也很重要）；但更重要重要的是学习方法，即从何处着手学习Linux内核，例如：如何调试内核、如何看懂内核中的汇编代码，如何分析系统调用等。这也是我学习之后最大的收获。总之，虽然网课结束了但学习还没有结束，继续加油~
