原创作品转载请注明出处 +《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000

# 前言：课程概述

本课程从理解计算机硬件的核心工作机制（存储程序计算机和函数调用堆栈）和用户态程序如何通过系统调用陷入内核（中断异常）入手，通过上下两个方向双向夹击的策略，并利用实际可运行程序的反汇编代码从实践的角度理解操作系统内核，然后开始分析Linux内核源代码，从系统调用陷入内核，进程调度与进程切换，最后返回到用户态进程，通过仔细分析梳理这一过程，并推广到硬件中断、缺页异常等内核执行路径，最终能从本质上把握Linux内核的实质，乃至在头脑中演绎Linux系统的运行过程。

# 一、Linux系统的理解

## 1.Linux架构

首先，一张典型的Linux操作系统架构图镇楼

![这里写图片描述](http://img.blog.csdn.net/20170423153839018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NzA4Njk4NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

*上图来自孟老师视频中的截图*

下表是对这张图进行的简要描述，为了便于描述，上图中，根据不同颜色划分，自下而上，最底层为第1层，向上层数依次递增。

| 层数 | 描述 |
| --|--|
| 第1层 | **最底层**：管理磁盘、物理内存等，还有内存控制器和控制台等基础功能的资词|
| 第2层 | **硬件接口层**：对硬件资源的管理|
| 第3层 | **内核实现层** ：实现操作系统主要功能，包括：CPU的调度、内存管理、虚拟内存、磁盘管理、文件系统等|
| 第4层 | **系统调用接口** ：内核提供的一系列的函数接口。一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。|
| 第5层 | **基础软件** ：提供编译器、Shell命令等基础软件|
| 第6层 | **用户程序** ：可供普通应用程序运行层|

## 2.Linux系统的一般执行过程

*这部分内容出自孟老师的课件，有部分改动*

**最一般的情况**

正在运行的用户态进程X切换到运行用户态进程Y的过程

![这里写图片描述](http://img.blog.csdn.net/20170423155626811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NzA4Njk4NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**几种特殊情况**

- 通过中断处理过程中的调度时机，用户态进程与内核线程之间互相切换和内核线程之间互相切换，与最一般的情况非常类似，只是内核线程运行过程中发生中断没有进程用户态和内核态的转换；
- 内核线程主动调用schedule()，只有进程上下文的切换，没有发生中断上下文的切换，与最一般的情况略简略；
- 创建子进程的系统调用在子进程中的执行起点及返回用户态，如fork；
- 加载一个新的可执行程序后返回到用户态的情况，如execve；

## 3.自己的理解

1) Linux操作系统工作过程中最主要的事情就是进程的切换，在进程切换的过程中会发生中断处理，这时会有内核堆栈的切换，汇编代码是理解的关键。其中中断和中断返回过程会有一个CPU上下文的切换；在进程调度的过程中有一个进程上下文的切换，即从一个进程的内核堆栈切换到另一个进程的内核堆栈。

在理解进程切换的工作过程时，我们可以利用gdb命令对内核代码设置断点进行调试跟踪，其中switch\_to、sys_clone、do_fork等等都是很重要的函数。

2) 在运行某个进程的时候，系统会先调用gets从用户态进入内核态，把各种信息压栈之后，进入系统调用等待键盘的输入，此时它处于阻塞态。在等待的过程中CPU可能会先调度到执行其他的进程，当有键盘输入后，就会发生I/O中断，然后就可以调度回一开始的进程。当前进程执行完之后可能会进入idle，也可能会执行其他进程。

在进程等待的过程中，若键盘输入了ls，CPU就会开始执行中断处理程序，进程管理就会切换到此进程，当gets系统调用获得数据后就会返回到用户态，继续执行下面的指令。


# 二、课程进行知识点总结

## 第一节、计算机是如何工作的

### 1.存储程序计算机工作模型

![这里写图片描述](http://img.blog.csdn.net/20170423112617986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NzA4Njk4NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 2.计算机的汇编指令

#### 1）movl指令：

| 寻址方式 | 描述 
| --- | ---- 
| **寄存器寻址** |寄存器模式，以％开头的寄存器标示符。不和内存打交道，eax赋值给edx 
|**立即寻址** |把立即数直接放在寄存器，立即数是以$开头的数值
| **直接寻址**|直接访问一个指定的内存地址的数据；
| **间接寻址**|将寄存器的值作为一个内存地址来访问内存；
| **变址寻址**|在间接寻址之时改变寄存器的数值。
 　
ebp：堆栈基指针，指向栈的底部（Base Pointer）
esp：堆栈顶指针，指向栈的顶部（StackPointer）
 　
**注意**：AT&T汇编格式与Intel汇编格式略有不同，Linux内核使用的是AT&T汇编格式。

#### 2）其他指令

堆栈是向下增长的，有一个基址ebp指向堆栈栈底

| 指令 | 描述 |
| --- | ---- |
| pushl | 压栈，esp减4，把eax放入esp内存位置 |
| popl | 出栈，从堆栈栈顶取32位放到寄存器eax里面，有两个动作：首先间接寻址，把栈顶数值放到eax里面，再把栈顶加4 |
| call | 函数调用，把当前的eip压栈，给eip赋新值 |
| enter| pushl %ebp;movl %esp, %ebp;|
| leave| movl  %ebp;popl %ebp; |

　
**注意**：*是指这些指令是伪指令，程序员不能直接修改这些，即eip寄存器不能被直接修改，只能通过特殊指令间接修改。

### 3.将C代码编译成汇编代码

1) 函数调用堆栈是由逻辑上多个堆栈叠加起来的
	
2) 函数的返回值默认使用eax寄存器存储返回给上一级函数
	
3) 使用命令编译成汇编代码：gcc –S –o main.s main.c -m32


### 4.小结
计算机的基本原理是存储程序和程序控制。预先要把指挥计算机如何进行操作的指令序列（称为程序）和原始数据通过输入设备输送到计算机内存贮器中。每一条指令中明确规定了计算机从哪个地址取数，进行什么操作，然后送到什么地址去等步骤。

计算机在运行时，CPU就是一直不停的工作，只要有指令产生，就依次执行，直至遇到停止指令。内存中存放着各种指令和数据，总线将两者相连接。

## 第二节、操作系统是如何工作的

### 1.三个法宝

- 存储程序计算机
- 函数调用堆栈
- 中断机制。

### 2. 操作系统两把宝剑
- 中断上下文的切换（保存现场和恢复现场）
- 进程上下文的切换

### 3. 堆栈及其操作
- **堆栈**：C语言程序运行时必须的一个记录调用路径和参数的空间。包括：函数调用框架；传递参数；保存返回地址（如eax）；提供局部变量空间

- **堆栈操作**：push栈顶指针减少4个字节（32位）和pop 栈顶指针增加4个字节

### 4. 参数传递与局部变量

#### 1）建立框架（相当于 call 指令）

```
push %ebp
movl %esp,%ebp
```

#### 2）拆除框架（相当于 ret 指令）

```
movl %ebp,%esp

pop  %ebp
```

函数返回时一定会拆除框架，建立和拆除是一一对应的。

#### 3）传递参数

在建立子函数的框架之前，局部变量的值保存在调用者堆栈框架中，所以在子函数框架建立之前可以采用变址寻址的方式将变量值入栈。

函数的返回值通过eax寄存器传递。

## 第三节、构造一个简单的Linux系统MenuOS

### 1.Linux内核源代码

![这里写图片描述](http://img.blog.csdn.net/20170423161050565?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NzA4Njk4NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

*图片来源：[跟踪分析Linux内核的启动过程](https://xuezhaojiang.github.io/LinuxCore/lab3/lab3.html)*

### 2.简单分析一下start_kernel

init\_task即手工创建的PCB，它是被静态产生的，内存栈的位置固定,执行一些初始化的工作。

sched_init()进程调度初始化函数，函数内关键的初始化——对0号进程，即idle进程进行初始化。当系统没有进程需要执行时，就调度到idle进程（0号进程）


### 3. 小结

系统进入start\_kernel这个函数之前已经进行了一些最低限度的初始化，再往前研究就涉及很多硬件相关及编程语言了。内核即进入了C语言部分，它完成了内核的大部分初始化工作。实际上，可以将start_kernel函数看做内核的main函数。

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。整个linux系统的所有进程也是一个树形结构。Linux下有3个特殊的进程，idle进程(PID = 0), init进程(PID = 1)和kthreadd(PID = 2)。


## 第四节、扒开系统调用的三层皮（上）

### 1.用户态和内核态

用户态：在相应的低执行状态下，代码的掌控范围受到限制，只能在对应级别允许的范围内活动
内核态：在高执行级别下，代码可以执行特权指令，访问任意的物理地址。
Intel x86 CPU有四种不同的执行级别0—3，Linux只是用了期中的0级和3级分别表示内核态和用户态。

### 2.理解中断处理的完整过程
中断信号（int指令）完成：保存cs:eip的值、当前堆栈段栈顶和当前标志，同时加载了当前中断信号或是系统调用的相关联的中断服务入口到cs:eip里面，把当前对战段和esp也加载到CPU里面。

SAVE ALL完成后若没有发生调度，则接着执行RESTORE_ALL；若发生进程调度，则当前的状态会暂时的保存在系统里面，当下一次发生进程调度切换到当前进程时再接着执行完毕。

### 3. 系统调用的三个层次

系统调用的三个层次依次是：xyz函数（API）、system_ call（中断向量）和 sys_ xyz（中断服务程序）。

### 4. 小结：

系统调用是用户态与内核态的桥梁，而具体的措施就是中断。通过本实验，更加熟悉了系统调用的本质，以及系统调用和中断的关联。应用程序在用户态调用API函数，该函数将对应的系统调用号及参数保存，触发软中断，然后陷入内核态，system_call根据系统调用号调用对应的内核函数，内核函数执行完毕后将结果存放的eax中并返回给程序，程序返回的用户态。

## 第五节、扒开系统调用的三层皮（下）

### 1. make rootfs
一个脚本，自动编译自动生成根文件系统，并自动启动MenuOS。

### 2. gdb

```
（gdb）file linux-3.18.6/vmlinux  //在gdb界面中targe remote之前加载符号表

（gdb）target remote:1234  //建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行

（gdb）b sys_time

（gdb）c   //启动到MenuOs，在MenuOs中使用time，会停在time函数处

（gdb）list  //对应代码

（gdb）s    //单步执行

（gdb）finish  //将这个函数执行完
```

### 3. iret
32位x86 Linux系统中系统调用处理过程的最后一条汇编指令。

### 4. SAVE_ALL
Linux内核中，SAVE_ALL是系统调用处理过程中保护现场使用的宏。

### 5. 小结
- 执行int 0x80指令后系统从用户态进入内核态，跳到system_call()函数处执行相应服务进程。在此过程中内核先保存中断环境，然后执行系统调用函数。
- system_call()函数通过系统调用号查找系统调用表sys_cal_table来查找具体系统调用服务进程。
- 执行完系统调用后，iret之前，内核会检查是否有新的中断产生、是否需要进程切换、是否学要处理其它进程发送过来的信号等。
- 内核是处理各种系统调用的中断集合，通过中断机制实现进程上下文的切换，通过系统调用管理整个计算机软硬件资源。 
- 如没有新的中断，restore保存的中断环境并返回用户态完成一个系统调用过程。




## 第六节、分析Linux内核创建一个新进程的过程

### 1.操作系统内核三大功能
- **进程管理**（核心）
- 内存管理
- 文件系统。

### 2.创建一个新进程在内核中的执行过程 
1) 使用系统调用sys\_clone(或fork,vfork)系统调用创建一个新进程，而且都是通过调用do_fork来实现进程的创建； 
2) Linux通过复制父进程PCB的task_struct来创建一个新进程，要给新进程分配一个新的内核堆栈; 
3) 要修改复制过来的进程数据，比如pid、进程链表等等执行copy_process和copy_thread 
4) p->thread.sp = (unsigned long) childregs; //调度到子进程时的内核栈顶 
5) p->thread.ip = (unsigned long) ret_from_fork; //调度到子进程时的第一条指令地址

## 第七节、 Linux内核如何装载和启动一个可执行程序


### 1．可执行程序过程

![这里写图片描述](http://img.blog.csdn.net/20170423170249480?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NzA4Njk4NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

*图片来自孟老师视频截图*

### 2. do_ execve
do_ execve调用do_ execve_ common，do_ execve_ common主要依靠exec_ binprm，其中重要的函数：search\_binary_handler(bprm)。

### 3.小结
新的可执行程序是从new\_ip开始执行,start_thread实际上是把返回到用户态的位置从Int 0x80的下一条指令，变成了规定的新加载的可执行文件的入口位置,即修改内核堆栈的EIP的值作为新程序的起点。 

当执行到execve系统调用时，陷入内核态，用execve加载的可执行文件覆盖当前进程的可执行程序，当execve系统调用返回时，返回新的可执行程序的执行起点（main函数位置），所以execve系统调用返回后新的可执行程序能顺利执行。 

对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时，如果是静态链接，elf\_entry指向可执行文件规定的头部（main函数对应的位置0x8048***）；如果需要依赖动态链接库，elf_entry指向动态链接器的起点。动态链接主要是由动态链接器ld来完成的。

## 第八节、进程的切换和系统的一般执行过程

### 1.进程调度算法

每个进程对CPU、I/O等资源需求不一样，有两种分类：

**第一种分类**：I/O密集型（I/O-bound）和CPU密集型（CPU-bound）
**第二种分类**：批处理进程；实时进程；交互式进程

### 2．进程调度的时机：

1) 中断处理过程（包括时钟中断、I/O中断、系统调用和异常）中，直接调用schedule()，或者返回用户态时根据need_resched标记调用schedule()；
2) 内核线程（只有内核态没有用户态）可以直接调用schedule()进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；
3) 用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度，即在中断处理过程中进行调度。

**注意**：用户态进程只能被动调度，内核线程是只有内核态没有用户态的特殊进程。

### 3. 操作系统有两个目的：

与硬件交互，管理所有的硬件资源；
为用户程序（应用程序）提供一个良好的执行环境。

### 4. 小结
本次课程学习了操作系统如何进行进程的切换以及系统的一般执行过程。其中还是脱离不出中断的使用，进程切换最主要的时机就在于中断的过程，对关键函数switch\_to的跟踪分析以及函数解读清晰地展示了堆栈如何变化的。

schedule()函数用来选择一个新的进程来运行，并调用context_switch()进行上下文的切换，这个宏调用switch_to()来进行关键上下文切换，其中pick_next_task()函数封装了进程调度算法。

# 三、学习心得体会

通过半个学期的学习，我认为重要的不是学习到了多少内核代码（其实也很重要）；但更重要重要的是学习方法，即从何处着手学习Linux内核，例如：如何调试内核、如何看懂内核中的汇编代码，如何分析系统调用等。这也是我学习之后最大的收获。总之，虽然网课结束了但学习还没有结束，继续加油~

# 附录：每周博客作业链接汇总

[第1节 反汇编一个简单的C程序【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/56282546)

[第2节 一个简单的时间片轮转多道程序内核代码【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/60148177)

[第3节 跟踪分析Linux内核的启动过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/61656277)

[第4节 使用库函数API和C代码中嵌入汇编代码两种方式使用同一个系统调用【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/63686845)

[第5节 分析system_call中断处理过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/66479846)

[第6节 分析Linux内核创建一个新进程的过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/68953502)

[第7节 Linux内核如何装载和启动一个可执行程序【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/69939026)

[第8节 理解进程调度时机跟踪分析进程调度与进程切换的过程【Linux内核分析】](http://blog.csdn.net/qq470869852/article/details/70198782)

